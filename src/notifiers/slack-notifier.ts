import axios from 'axios';
import { JiraIssue } from '../jira-client-secure.js';
import { InputValidator } from '../validators.js';

export interface SlackMessage {
  text?: string;
  blocks?: any[];
  attachments?: any[];
}

export class SlackNotifier {
  private webhookUrl: string;
  private channel?: string;
  private username: string;

  constructor(webhookUrl: string, channel?: string, username: string = 'Jira MCP Bot') {
    if (!webhookUrl) {
      throw new Error('Slack webhook URL is required');
    }

    // Validate webhook URL format
    if (!/^https:\/\/hooks\.slack\.com\/services\//.test(webhookUrl)) {
      throw new Error('Invalid Slack webhook URL format');
    }

    this.webhookUrl = webhookUrl;
    this.channel = channel;
    this.username = username;
  }

  async sendClosedItemsNotification(issues: JiraIssue[], boardName: string): Promise<void> {
    if (issues.length === 0) {
      return;
    }

    const message = this.buildClosedItemsMessage(issues, boardName);
    await this.send(message);
  }

  async sendBlogNotification(blogContent: string, issueCount: number): Promise<void> {
    const message = this.buildBlogMessage(blogContent, issueCount);
    await this.send(message);
  }

  private buildClosedItemsMessage(issues: JiraIssue[], boardName: string): SlackMessage {
    const groupedIssues = this.groupIssuesByType(issues);
    const date = new Date().toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });

    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `üìä Jira Update - ${boardName}`,
          emoji: true
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*${issues.length} items* completed as of ${date}`
        }
      },
      {
        type: 'divider'
      }
    ];

    // Add summary by type
    for (const [type, typeIssues] of groupedIssues.entries()) {
      const emoji = this.getEmojiForType(type);

      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `${emoji} *${type}s (${typeIssues.length})*`
        }
      });

      // Add top 3 items for each type
      const topItems = typeIssues.slice(0, 3);
      const itemsList = topItems
        .map(issue => `‚Ä¢ <https://your-domain.atlassian.net/browse/${issue.key}|${issue.key}>: ${this.truncate(issue.fields.summary, 60)}`)
        .join('\n');

      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: itemsList
        }
      });
    }

    // Add footer
    blocks.push(
      {
        type: 'divider'
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `_Generated by Jira MCP Server | ${new Date().toISOString()}_`
        }
      }
    );

    return { blocks };
  }

  private buildBlogMessage(blogContent: string, issueCount: number): SlackMessage {
    // Extract title from blog content
    const titleMatch = blogContent.match(/^# (.+)$/m);
    const title = titleMatch ? titleMatch[1] : 'Product Update';

    // Create a summary
    const summary = this.truncate(
      blogContent.replace(/^#.*$/gm, '').replace(/\*/g, '').trim(),
      500
    );

    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: 'üìù New Blog Post Generated',
          emoji: true
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*${title}*\n\n_${issueCount} items included in this update_`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: summary
        }
      },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'View Full Post',
              emoji: true
            },
            value: 'view_post',
            action_id: 'view_post',
            style: 'primary'
          },
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Edit in CMS',
              emoji: true
            },
            value: 'edit_post',
            action_id: 'edit_post'
          }
        ]
      }
    ];

    return { blocks };
  }

  private async send(message: SlackMessage): Promise<void> {
    try {
      const payload: any = {
        ...message,
        username: this.username
      };

      if (this.channel) {
        payload.channel = this.channel;
      }

      const response = await axios.post(this.webhookUrl, payload, {
        headers: { 'Content-Type': 'application/json' },
        timeout: 5000
      });

      if (response.data !== 'ok') {
        throw new Error(`Slack API returned: ${response.data}`);
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Failed to send Slack notification: ${InputValidator.sanitizeErrorMessage(message)}`);
    }
  }

  private groupIssuesByType(issues: JiraIssue[]): Map<string, JiraIssue[]> {
    const grouped = new Map<string, JiraIssue[]>();

    for (const issue of issues) {
      const type = issue.fields.issuetype.name;
      if (!grouped.has(type)) {
        grouped.set(type, []);
      }
      grouped.get(type)!.push(issue);
    }

    return grouped;
  }

  private getEmojiForType(type: string): string {
    const emojiMap: { [key: string]: string } = {
      'Bug': 'üêõ',
      'Story': '‚ú®',
      'Task': 'üîß',
      'Epic': 'üéØ',
      'Feature': 'üöÄ',
      'Improvement': '‚ö°',
      'Sub-task': 'üìå'
    };

    return emojiMap[type] || 'üìã';
  }

  private truncate(text: string, maxLength: number): string {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - 3) + '...';
  }
}